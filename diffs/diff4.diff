diff --git a/src/diff.rs b/src/diff/diff_type.rs
similarity index 63%
rename from src/diff.rs
rename to src/diff/diff_type.rs
index 9186f24..d444579 100644
--- a/src/diff.rs
+++ b/src/diff/diff_type.rs
@@ -1,52 +1,5 @@
-use result::Result; // Result directly is our result.
-use std::collections::{HashMap, HashSet};
-use std::fs::read;
-use std::path::Path;
-
-/// Given a file, return statistical information about the file as if it were a diff file.
-/// Returns Some Result if the file could be read and None if the reading failed.
-///
-/// # Arguments
-///
-/// `file` - The path to the file to be analized
-///
-/// # Advice
-///
-/// This will be the main function per file.
-/// It is adviced to create a handler around this as this function is not taking exclusive
-/// rights to the path.  The path should be secured by the handler for the sake of returning
-/// an error message if the path was invalid and no data could be read.
-pub fn diffStats(file: &Path) -> Option<Result> {
-    if let Ok(file_data) = read(file) {
-        let mut retVal = Result::new(HashSet::new(), 0, 0, 0, HashMap::new());
-        let file_data = match String::from_utf8(file_data) {
-            Ok(data) => data,
-            Err(_) => {
-                eprintln!("Error: Could not encode file as utf8");
-                return None;
-            }
-        };
-        let mut diff_format_typer = DiffFormatTyper::new();
-        let lines = file_data.lines();
-        for line in lines {
-            match diff_format_typer.type_line(line) {
-                None => break,
-                Some(DiffType::NewRegion) => retVal.add_region(),
-                Some(DiffType::Addition) => retVal.count_added_line(),
-                Some(DiffType::Subtraction) => retVal.count_removed_line(),
-                _ => {}
-            };
-        }
-
-        Some(retVal)
-    } else {
-        None // During file error, we simply return nothing to indicate that the file has no contents instead of valid contents with nothing in it.
-    }
-}
-
-
 #[derive(Debug, Clone)]
-enum DiffType {
+pub enum DiffType {
     Header,
     Index,
     OriginalFile,
@@ -94,16 +47,16 @@ fn diff_type(line: &str) -> DiffType {
     }
 }
 
-struct DiffFormatTyper {
+pub struct DiffFormatTyper {
     last: Option<DiffType>,
 }
 
 impl DiffFormatTyper {
-    fn new() -> Self {
+    pub fn new() -> Self {
         DiffFormatTyper { last: None }
     }
 
-    fn type_line(&mut self, line: &str) -> Option<DiffType> {
+    pub fn type_line(&mut self, line: &str) -> Option<DiffType> {
         let diff_type = diff_type(line);
         let diff_type_fixed = match self.last.clone() {
             None => {
@@ -194,39 +147,3 @@ impl DiffFormatTyper {
         self.last.clone()
     }
 }
-
-
-#[cfg(test)]
-mod tests {
-    use std::path::Path;
-
-    use result::Result;
-    use super::diffStats;
-
-    #[test]
-    fn invaldFile() {
-        let path = Path::new("/INVALID");
-        assert!(match diffStats(&path) {
-                    None => true,
-                    _ => false,
-                });
-    }
-
-    #[test]
-    fn emptyFile() {
-        use std::fs::{write, remove_file};
-        let filename = "test.tmp"; // We create an empty file just to be sure it exists.
-        write(&filename, "");
-        let path = Path::new(&filename);
-        assert!(match diffStats(&path) {
-                    Some(_) => true,
-                    _ => false,
-                });
-        // TODO implementing PartialEq on result to improve this test to the next line.
-        // assert!(match diffStats(&path){ Some(data) => data == Result::empty(), _ => false});
-        remove_file(&filename); // Cleanup that file so we don't keep creating different files.
-
-        // TODO crate tempfile should be introduced in test setup to improve this test by
-        // removing the issue with creating and removing a file.
-    }
-}
diff --git a/src/diff/mod.rs b/src/diff/mod.rs
new file mode 100644
index 0000000..0e51f5f
--- /dev/null
+++ b/src/diff/mod.rs
@@ -0,0 +1,83 @@
+use result::Result; // Result directly is our result.
+use std::collections::{HashMap, HashSet};
+use std::fs::read;
+use std::path::Path;
+
+mod diff_type;
+use self::diff_type::{DiffType, DiffFormatTyper};
+
+/// Given a file, return statistical information about the file as if it were a diff file.
+/// Returns Some Result if the file could be read and None if the reading failed.
+///
+/// # Arguments
+///
+/// `file` - The path to the file to be analized
+///
+/// # Advice
+///
+/// This will be the main function per file.
+/// It is adviced to create a handler around this as this function is not taking exclusive
+/// rights to the path.  The path should be secured by the handler for the sake of returning
+/// an error message if the path was invalid and no data could be read.
+pub fn diffStats(file: &Path) -> Option<Result> {
+    if let Ok(file_data) = read(file) {
+        let mut retVal = Result::new(HashSet::new(), 0, 0, 0, HashMap::new());
+        let file_data = match String::from_utf8(file_data) {
+            Ok(data) => data,
+            Err(_) => {
+                eprintln!("Error: Could not encode file as utf8");
+                return None;
+            }
+        };
+        let mut diff_format_typer = DiffFormatTyper::new();
+        let lines = file_data.lines();
+        for line in lines {
+            match diff_format_typer.type_line(line) {
+                None => break,
+                Some(DiffType::NewRegion) => retVal.add_region(),
+                Some(DiffType::Addition) => retVal.count_added_line(),
+                Some(DiffType::Subtraction) => retVal.count_removed_line(),
+                _ => {}
+            };
+        }
+
+        Some(retVal)
+    } else {
+        None // During file error, we simply return nothing to indicate that the file has no contents instead of valid contents with nothing in it.
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use std::path::Path;
+
+    use result::Result;
+    use super::diffStats;
+
+    #[test]
+    fn invaldFile() {
+        let path = Path::new("/INVALID");
+        assert!(match diffStats(&path) {
+                    None => true,
+                    _ => false,
+                });
+    }
+
+    #[test]
+    fn emptyFile() {
+        use std::fs::{write, remove_file};
+        let filename = "test.tmp"; // We create an empty file just to be sure it exists.
+        write(&filename, "");
+        let path = Path::new(&filename);
+        assert!(match diffStats(&path) {
+                    Some(_) => true,
+                    _ => false,
+                });
+        // TODO implementing PartialEq on result to improve this test to the next line.
+        // assert!(match diffStats(&path){ Some(data) => data == Result::empty(), _ => false});
+        remove_file(&filename); // Cleanup that file so we don't keep creating different files.
+
+        // TODO crate tempfile should be introduced in test setup to improve this test by
+        // removing the issue with creating and removing a file.
+    }
+}
